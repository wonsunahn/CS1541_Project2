<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CS 1541 Project 2: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CS 1541 Project 2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">README</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li>CS/COE 1541 - Introduction to Computer Architecture</li>
</ul>
<p>Introduction</p><ul>
<li>Description</li>
<li>Processor Design</li>
</ul>
<p>Building and Running</p><ul>
<li>Environment Setup</li>
<li>Directory Structure and Makefile Script</li>
<li>Program Output<ul>
<li>Solution Binary</li>
<li>Current Binary</li>
</ul>
</li>
<li>Configuration Files</li>
<li>Trace Files</li>
</ul>
<p>Your Tasks</p><ul>
<li>Task 1: Implement the Cache Block Array</li>
<li>Task 2: Implement the Write-back and Write-through Caches</li>
<li>Source Code</li>
<li>Submission</li>
</ul>
<p>Resources</p>
<h1><a class="anchor" id="autotoc_md0"></a>
CS/COE 1541 - Introduction to Computer Architecture</h1>
<p>Spring Semester 2023 - Project 2</p>
<p>Please accept Project 2 on <b>GitHub Classroom</b> using the following link: TBD</p>
<ul>
<li>DUE: Apr 26 (Friday), 2024 11:59 PM</li>
</ul>
<h1><a class="anchor" id="autotoc_md1"></a>
Introduction</h1>
<h2><a class="anchor" id="autotoc_md2"></a>
Description</h2>
<p>The goal of this project is to create a software simulator for an in-order processor with a configurable memory hierarchy. I've already explained why building simulators is important in Project 1, so I will not belabor that point. :)</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Processor Design</h2>
<p>The processor that you will simulate is configured with a memory hierarchy that looks as follows:</p>
<p><img src="Project2_diagram.png" alt="Memory hierarchy" width="700" class="inline"/></p>
<p>We will only test a 1-wide processor because we are focusing on memory stalls this time. You will also ignore all pipeline hazards for the same reason.</p>
<p>The processor has split data and instruction L1 caches and a unified L2 cache below it. Below that sits the <a class="el" href="classDRAM.html" title="A DRAM memory.">DRAM</a> memory. In the test configurations, the L2 cache is always configured as a write-back (WB) cache to reduce bandwidth consumption to memory. The L1 cache is configured as either a write-through (WT) cache or a write-back (WB) cache. Write-back and write-through caches work in exactly the same way as explained during the lecture. Please review the lecture if you don't remember.</p>
<p>The processor pipeline has a write-buffer to maintain pending stores. The write-buffer allows store instructions which may potentially suffer a long delay to commit immediately as long as there is space in the write-buffer. While the store is pending, load instructions that hit on the pending store can return immediately as well. The write-buffer is assumed to be fully associative (as is true in most processors).</p>
<p>Each cache also has a dedicated write-buffer for write-back memory requests. We are going to assume for simplicity that all cache write-buffers are infinitely sized. That means that the processor will never suffer stalls due to write-backs of dirty blocks.</p>
<p>Also, each cache is a non-blocking cache, meaning that while the cache is waiting on a cache miss, the cache can continue servicing other memory requests, be they cache hits or cache misses. This is done through the Miss Status Handling Register (MSHR) table that we discussed briefly in class. Each entry in the table has an ID for each missing memory request and the required action when the request returns from the lower memory hierarchy. This allows the cache to handle multiple outstanding misses that may return out-of-order from the lower memory hierarchy. We are also going to assume that the MSHR table is infitely sized so that we can have an infinite number of outstanding misses and never have to block.</p>
<h1><a class="anchor" id="autotoc_md4"></a>
Building and Running</h1>
<h2><a class="anchor" id="autotoc_md5"></a>
Environment Setup</h2>
<p>Please refer to <a href="https://github.com/wonsunahn/CS1541_Project1/#creating-build-environment-on-local-machine">Project 1 Environment Setup</a> on how to set up your local VSCode developement environment. If you already did the setup, you don't need to do anything in addition. If you have trouble with the setup, please feel free to use GitHub codespaces that fires up a Docker container VSCode development environment pre-configured with the necessary packages.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Directory Structure and Makefile Script</h2>
<p>Here is an overview of the directory structure:</p>
<div class="fragment"><div class="line"># Source code you will be **modifying**.</div>
<div class="line">CacheCore.cpp / CacheCore.h : A cache block array organized into rows and columns.</div>
<div class="line">Cache.h / Cache.cpp : Contains classes for a write-back cache and a write-through cache.</div>
<div class="line"> </div>
<div class="line"># Source code newly added as part of Project 2.</div>
<div class="line">CacheLine.h : A cache line (a.k.a. a cache block) with tag, valid bit, dirty bit, and age.</div>
<div class="line">Counter.h : A counter for statistics reporting.</div>
<div class="line">DRAM.h : DRAM memory, which mostly acts like a cache that always hits.</div>
<div class="line">MemObj.cpp / MemObj.h : Parent class for all memory objects (caches and DRAM).</div>
<div class="line">MemRequest.cpp / MemRequest.h : Memory request that gets passed around memory objects.</div>
<div class="line">WriteBuffer.h : Write buffer attached to the processor pipeline</div>
<div class="line">log2i.cpp / log2i.h : Contains the log2i function, a log2 for integers.</div>
<div class="line"> </div>
<div class="line"># Directory newly added as part of Project 2.</div>
<div class="line">doc/ : Directory where Doxygen documentation of the source code is kept.</div>
<div class="line"> </div>
<div class="line"># Source code inherited from Project 1 with small modifications.</div>
<div class="line">five_stage_solution(.linux/.exe/.mac) : **Reference solution** binaries for each OS.</div>
<div class="line">Makefile : The build script for the Make tool.</div>
<div class="line">config.c / config.h : Functions used to parse and read in the processor configuration file.</div>
<div class="line">CPU.c / CPU.h : Implements the five stages of the processor pipeline, modified to consider memory stalls.</div>
<div class="line">five_stage.c : Main function. Parses commandline arguments and invokes the five stages at every clock cycle.</div>
<div class="line">trace.c / trace.h : Functions to read and write the trace file.</div>
<div class="line">trace_generator.c : Utility program to generate a trace file of your own.</div>
<div class="line">trace_reader.c : Utility program to read and print out the contents of a trace file in human readable format.</div>
<div class="line">confs/ : Directory where processor configuration files are.</div>
<div class="line">diffs/ : Directory with diffs between outputs/ and outputs_solution/ are stored.</div>
<div class="line">outputs/ : Directory where outputs after running five_stage are stored.</div>
<div class="line">outputs_solution/ : Directory where outputs produced by five_stage_solution are stored.</div>
<div class="line">plot_confs/ : Directory where processor configurations for the plot generation are.</div>
<div class="line">plot_outputs/ : Directory where outputs after running five_stage are stored for plot generation.</div>
<div class="line">plots_outputs_solution/ : Directory where outputs after running five_stage_solution are stored for plot generation.</div>
<div class="line">traces/ : Directory where instruction trace files used to test the simulator are stored.</div>
</div><!-- fragment --><p>In order to build the project and run the simulations, you only need to do 'make' to invoke the 'Makefile' script:</p>
<div class="fragment"><div class="line">make</div>
</div><!-- fragment --><p>The output should being with:</p>
<div class="fragment"><div class="line">g++ -c -g -Wall -Wno-format-security -std=c++11 -I/usr/include/glib-2.0/ -I/usr/lib/x86_64-linux-gnu/glib-2.0/include/ five_stage.c</div>
<div class="line">g++ -c -g -Wall -Wno-format-security -std=c++11 -I/usr/include/glib-2.0/ -I/usr/lib/x86_64-linux-gnu/glib-2.0/include/ config.c</div>
<div class="line">g++ -c -g -Wall -Wno-format-security -std=c++11 -I/usr/include/glib-2.0/ -I/usr/lib/x86_64-linux-gnu/glib-2.0/include/ CPU.c</div>
<div class="line">g++ -c -g -Wall -Wno-format-security -std=c++11 -I/usr/include/glib-2.0/ -I/usr/lib/x86_64-linux-gnu/glib-2.0/include/ trace.c</div>
<div class="line">...</div>
</div><!-- fragment --><p>As in Project 1, the results of the simulations are stored in the outputs/ directory and also side-by-side diffs with the outputs_solution/ directory are generated and stored in the diffs/ directory. When you debug the program, you will find these side-by-side diffs useful.</p>
<p>You can generate your own traces using the trace_generator and put it inside the traces/ directory or create a new configuration inside the confs/ directory, and they will be incorporated into the results automatically by the Makefile script. <br  />
</p>
<p>The uses of the 'make build', 'make clean', and 'make distclean' commands are identical to Project 1.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Program Output</h2>
<p>As before five_stage.c reads in a trace file (a binary file containing a sequence of executed instructions) and simulates the processor described above. But since the cache implementation is as of now incomplete, the L1 and L2 caches will always miss and you will always go to <a class="el" href="classDRAM.html" title="A DRAM memory.">DRAM</a> memory (unless you hit in the write-buffer, of course). Your goal is to complete the cache implementation so that the accesses hit in the caches when appropriate.</p>
<h3><a class="anchor" id="autotoc_md8"></a>
Solution Binary</h3>
<p>Let's start by looking at five_stage_solution (the solution binary) to see how the output <em>should</em> look like.</p>
<p>Try doing the following, choosing the file extension that is appropriate for your OS:</p>
<div class="fragment"><div class="line">./five_stage_solution(.linux/.exe/.mac) -t traces/two_stores.tr -c confs/l1-wb.conf -d</div>
</div><!-- fragment --><p>Or, alternatively open the 'outputs_solution/two_stores.l1-wb.out' file after doing 'make'.</p>
<p>And you should see the following output at the beginning:</p>
<div class="fragment"><div class="line">Memory system setup successful.</div>
<div class="line"> </div>
<div class="line">Printing all memory objects ... </div>
<div class="line"> </div>
<div class="line">[DL1Cache]</div>
<div class="line">device type = cache</div>
<div class="line">write policy = WB</div>
<div class="line">hit time = 2</div>
<div class="line">capacity = 8192</div>
<div class="line">block size = 64</div>
<div class="line">associativity = 1</div>
<div class="line">lower level = L2Cache</div>
<div class="line"> </div>
<div class="line">[IL1Cache]</div>
<div class="line">device type = cache</div>
<div class="line">write policy = WB</div>
<div class="line">hit time = 2</div>
<div class="line">capacity = 8192</div>
<div class="line">block size = 64</div>
<div class="line">associativity = 1</div>
<div class="line">lower level = L2Cache</div>
<div class="line"> </div>
<div class="line">[L2Cache]</div>
<div class="line">device type = cache</div>
<div class="line">write policy = WB</div>
<div class="line">hit time = 10</div>
<div class="line">capacity = 16384</div>
<div class="line">block size = 64</div>
<div class="line">associativity = 4</div>
<div class="line">lower level = Memory</div>
<div class="line"> </div>
<div class="line">[Memory]</div>
<div class="line">device type = dram</div>
<div class="line">hit time = 100</div>
<div class="line"> </div>
<div class="line">[WriteBuffer]</div>
<div class="line">device type = dram</div>
<div class="line">hit time = 1</div>
<div class="line"> </div>
<div class="line">======================================================================</div>
<div class="line">...</div>
</div><!-- fragment --><p>This is just saying that the configuration file has been successfully parsed and the memory hierarchy objects have been created and initialized correctly with the configuration parameters. You can see that all caches are configured to be 'WB' or write-back.</p>
<p>Next, you see the following output: </p><div class="fragment"><div class="line">======================================================================</div>
<div class="line">[IF CYCLE: 1] STORE: (Seq: 1)(Addr: 0x00009900)(PC: 0x00000000)</div>
<div class="line">IL1Cache-&gt;access(MemRead, addr: 0x00000000, latency: 2)</div>
<div class="line">L2Cache-&gt;access(MemRead, addr: 0x00000000, latency: 12)</div>
<div class="line">Memory-&gt;access(MemRead, addr: 0x00000000, latency: 112)</div>
<div class="line"> </div>
<div class="line">Printing all cache contents ...</div>
<div class="line">[DL1Cache]</div>
<div class="line">[IL1Cache]</div>
<div class="line">(0, 0) tag=0x0:valid=1:dirty=0:age=0</div>
<div class="line">[L2Cache]</div>
<div class="line">(0, 0) tag=0x0:valid=1:dirty=0:age=0</div>
<div class="line">[WriteBuffer]</div>
<div class="line"> </div>
<div class="line">Fast forwarding cycle: 1 -&gt; 112</div>
<div class="line">======================================================================</div>
</div><!-- fragment --><p>This shows your first memory access. It is saying that the instruction fetch (PC: 0) for the store instruction generated a read memory request (addr: 0) to the instruction L1 cache. Since initially the cache is empty, it will go down all the way to memory to fetch that cache block. You can see that at each level of the memory hierarchy, latency increases equal to the configured hit time parameter for that memory object. When the memory request returns, the current cycle is fast forwarded by the number of cycles that the CPU stalls waiting for the memory request (1 -&gt; 112). Since the CPU is going to be stalling and doing nothing for the duration of the request, it makes sense to fast forward to the point where the request returns. The number of stall cycles is calculated as 'latency - 1' (112 - 1). One is subtracted because one cycle is the latency for a pipeline stage and anything beyond that is what causes a stall.</p>
<p>Next, the cache contents of all the caches are dumped to output. Only valid blocks are dumped. The block string representation is interpreted as follows:</p>
<div class="fragment"><div class="line">(0, 0) tag=0x0:valid=1:dirty=0:age=0</div>
</div><!-- fragment --><p>This means that this cache block is in row 0, column 0 of the cache block array. Row is the set index and column is the index of the cache block within the set. Please use the cache visualizer under resources/cache_demo/ of the course repository to visualize the rows and columns. The rest is the various metadata for that cache block.</p>
<p>Next, you see the following output: </p><div class="fragment"><div class="line">======================================================================</div>
<div class="line">[IF CYCLE: 113] STORE: (Seq: 2)(Addr: 0x00009920)(PC: 0x00000004)</div>
<div class="line">IL1Cache-&gt;access(MemRead, addr: 0x00000004, latency: 2)</div>
<div class="line"> </div>
<div class="line">Printing all cache contents ...</div>
<div class="line">[DL1Cache]</div>
<div class="line">[IL1Cache]</div>
<div class="line">(0, 0) tag=0x0:valid=1:dirty=0:age=0</div>
<div class="line">[L2Cache]</div>
<div class="line">(0, 0) tag=0x0:valid=1:dirty=0:age=0</div>
<div class="line">[WriteBuffer]</div>
<div class="line"> </div>
<div class="line">Fast forwarding cycle: 113 -&gt; 114</div>
<div class="line">======================================================================</div>
</div><!-- fragment --><p>You see an instruction fetch for the next PC: 4. Due to spatial locality, this read to the instruction L1 cache hits. You can see that this time, the memory request just accesses the instruction L1 cache and immediately returns. The cache contents remain the same since no new blocks are allocated. The current cycle is fast forwarded by one cycle since the L1 cache access latency was 2.</p>
<p>Next, you see the following output: </p><div class="fragment"><div class="line">======================================================================</div>
<div class="line">[MEM CYCLE: 116] STORE: (Seq: 1)(Addr: 0x00009900)(PC: 0x00000000)</div>
<div class="line">WriteBuffer-&gt;access(MemWrite, addr: 0x00009900, latency: 1)</div>
<div class="line">DL1Cache-&gt;access(MemWrite, addr: 0x00009900, latency: 1)</div>
<div class="line">L2Cache-&gt;access(MemRead, addr: 0x00009900, latency: 1)</div>
<div class="line">Memory-&gt;access(MemRead, addr: 0x00009900, latency: 1)</div>
<div class="line"> </div>
<div class="line">Printing all cache contents ...</div>
<div class="line">[DL1Cache]</div>
<div class="line">(100, 0) tag=0x4:valid=1:dirty=1:age=0</div>
<div class="line">[IL1Cache]</div>
<div class="line">(0, 0) tag=0x0:valid=1:dirty=0:age=0</div>
<div class="line">[L2Cache]</div>
<div class="line">(0, 0) tag=0x0:valid=1:dirty=0:age=0</div>
<div class="line">(36, 0) tag=0x9:valid=1:dirty=0:age=0</div>
<div class="line">[WriteBuffer]</div>
<div class="line">tag=0x9900:pendingUntil:228</div>
<div class="line">======================================================================</div>
</div><!-- fragment --><p>You see the first STORE instruction performing the write access at the MEM stage with addr: 0x00009900. It first gets registered as a pending store in the write-buffer and then the MemWrite request is propagated down the memory hierarchy. It misses in the data L1 cache, which means that a new block must be allocated in the L1 and the data for the block read in from lower memory. So the MemWrite request is now mutated into a MemRead request to access the L2 cache. It misses there again and you have to go all the way <a class="el" href="classDRAM.html" title="A DRAM memory.">DRAM</a> memory. <br  />
</p>
<p>Now note that the latency of the memory request always shows as 1 even though it has to go all the way to memory. This is because the store is immediately committed as pending in the write-buffer without any stalling, and the write request performs behind the scenes. The write-buffer entry will be released at cycle 228 as indicated in the entry:</p>
<div class="fragment"><div class="line">tag=0x9900:pendingUntil:228</div>
</div><!-- fragment --><p>That is also why there is no fast forwarding that needs to happen here.</p>
<p>Looking at the cache contents, we see the new cache block read into the L2 cache:</p>
<div class="fragment"><div class="line">(36, 0) tag=0x9:valid=1:dirty=0:age=0</div>
</div><!-- fragment --><p>It's clean because it hasn't been modified. We also see the new cache block in the DL1 cache:</p>
<div class="fragment"><div class="line">(100, 0) tag=0x4:valid=1:dirty=1:age=0</div>
</div><!-- fragment --><p>This block is dirty because it was written to with the store data.</p>
<p>Next, you see the following output:</p>
<div class="fragment"><div class="line">======================================================================</div>
<div class="line">[MEM CYCLE: 117] STORE: (Seq: 2)(Addr: 0x00009920)(PC: 0x00000004)</div>
<div class="line">WriteBuffer-&gt;access(MemWrite, addr: 0x00009920, latency: 1)</div>
<div class="line">DL1Cache-&gt;access(MemWrite, addr: 0x00009920, latency: 1)</div>
<div class="line"> </div>
<div class="line">Printing all cache contents ...</div>
<div class="line">[DL1Cache]</div>
<div class="line">(100, 0) tag=0x4:valid=1:dirty=1:age=0</div>
<div class="line">[IL1Cache]</div>
<div class="line">(0, 0) tag=0x0:valid=1:dirty=0:age=0</div>
<div class="line">[L2Cache]</div>
<div class="line">(0, 0) tag=0x0:valid=1:dirty=0:age=0</div>
<div class="line">(36, 0) tag=0x9:valid=1:dirty=0:age=0</div>
<div class="line">[WriteBuffer]</div>
<div class="line">tag=0x9900:pendingUntil:228</div>
<div class="line">tag=0x9920:pendingUntil:119</div>
<div class="line">======================================================================</div>
</div><!-- fragment --><p>This is the MEM stage for the second store to addr: 0x00009920. The previous address 0x00009900 and 0x00009920 are on the same cache block so the data L1 cache hit. Again, the store is registered as pending in the write-buffer so no delay is incurred. Note that for new pending store, the store is only pending until cycle 119 (2 cycles later) as the store hits in the L1 cache.</p>
<p>Next, you see a summary of statistics for each memory object: </p><div class="fragment"><div class="line">Printing all memory stats ... </div>
<div class="line"> </div>
<div class="line">DL1Cache:readHits=0:readMisses=0:writeHits=1:writeMisses=1:writeBacks=0</div>
<div class="line">IL1Cache:readHits=1:readMisses=1:writeHits=0:writeMisses=0:writeBacks=0</div>
<div class="line">L2Cache:readHits=0:readMisses=2:writeHits=0:writeMisses=0:writeBacks=0</div>
<div class="line">Memory:readHits=2:writeHits=0</div>
<div class="line">WriteBuffer:readHits=0:readMisses=0:writeHits=0:writeMisses=2:writeOverflows=0</div>
<div class="line">+ Memory stall cycles : 112</div>
<div class="line">+ Number of cycles : 118</div>
<div class="line">+ IPC (Instructions Per Cycle) : 0.0169</div>
</div><!-- fragment --><p>There are a few invariants here:</p>
<ul>
<li>L2Cache hits + L2Cache misses = DL1Cache misses + IL1Cache misses + DL1Cache writeBacks + IL1Cache writeBacks</li>
<li>Memory hits = L2Cache misses</li>
</ul>
<p>Make sure they hold in your code too.</p>
<p>And then some final statistics: </p><div class="fragment"><div class="line">+ Memory stall cycles : 112</div>
<div class="line">+ Number of cycles : 118</div>
<div class="line">+ IPC (Instructions Per Cycle) : 0.0169</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md9"></a>
Current Binary</h3>
<p>As I said, the implementation is incomplete, so the L1 and L2 caches will always miss and you will always go to <a class="el" href="classDRAM.html" title="A DRAM memory.">DRAM</a> memory. Let's look at five_stage (the current binary) to see how the output looks like <em>now</em>.</p>
<p>Try doing the following:</p>
<div class="fragment"><div class="line">./five_stage(.linux/.exe/.mac) -t traces/two_stores.tr -c confs/l1-wb.conf -d</div>
</div><!-- fragment --><p>Or, alternatively open the 'outputs/two_stores.l1-wb.out' file after doing 'make'.</p>
<p>And you should see the following output after the preamble in the beginning:</p>
<div class="fragment"><div class="line">======================================================================</div>
<div class="line">[IF CYCLE: 1] STORE: (Seq: 1)(Addr: 0x00009900)(PC: 0x00000000)</div>
<div class="line">IL1Cache-&gt;access(MemRead, addr: 0x00000000, latency: 2)</div>
<div class="line">L2Cache-&gt;access(MemRead, addr: 0x00000000, latency: 12)</div>
<div class="line">Memory-&gt;access(MemRead, addr: 0x00000000, latency: 112)</div>
<div class="line"> </div>
<div class="line">Printing all cache contents ...</div>
<div class="line">[DL1Cache]</div>
<div class="line">[IL1Cache]</div>
<div class="line">[L2Cache]</div>
<div class="line">[WriteBuffer]</div>
<div class="line"> </div>
<div class="line">Fast forwarding cycle: 1 -&gt; 112</div>
<div class="line">======================================================================</div>
<div class="line">======================================================================</div>
<div class="line">[IF CYCLE: 113] STORE: (Seq: 2)(Addr: 0x00009920)(PC: 0x00000004)</div>
<div class="line">IL1Cache-&gt;access(MemRead, addr: 0x00000004, latency: 2)</div>
<div class="line">L2Cache-&gt;access(MemRead, addr: 0x00000004, latency: 12)</div>
<div class="line">Memory-&gt;access(MemRead, addr: 0x00000004, latency: 112)</div>
<div class="line"> </div>
<div class="line">Printing all cache contents ...</div>
<div class="line">[DL1Cache]</div>
<div class="line">[IL1Cache]</div>
<div class="line">[L2Cache]</div>
<div class="line">[WriteBuffer]</div>
<div class="line"> </div>
<div class="line">Fast forwarding cycle: 113 -&gt; 224</div>
<div class="line">======================================================================</div>
</div><!-- fragment --><p>You can see that on the instruction fetch for the first store, the read misses at all levels of the cache. But afterwards, no blocks are added to any of the caches. This causes the second instruction fetch to also miss, even though it is to the same cache block. Your job is to make this work.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Configuration Files</h2>
<p>You can find 2 configuration files under the confs/ directory. Each will configure a different processor when passed as the -c option to five_stage. The files are: l1-wb.conf and l1-wt.conf.</p>
<ul>
<li>l1-wb.conf.conf : Configuration where L1 caches are write-back (WB) caches.</li>
<li>l1-wt.conf.conf : Configuration where L1 caches are write-through (WT) caches.</li>
</ul>
<p>Other than the difference in the L1 write policy, all other parameters are equal.</p>
<p>Here is how the l1-wb.conf file looks like:</p>
<div class="fragment"><div class="line"># Processor pipeline</div>
<div class="line">[pipeline]</div>
<div class="line">width         = 1</div>
<div class="line">instSource    = IL1Cache</div>
<div class="line">dataSource    = WriteBuffer</div>
<div class="line"> </div>
<div class="line"># Instruction L1 cache</div>
<div class="line">[IL1Cache]</div>
<div class="line">deviceType    = cache</div>
<div class="line">size          = 8192            # 8 * 1024</div>
<div class="line">assoc         = 1</div>
<div class="line">bsize         = 64</div>
<div class="line">writePolicy   = WB</div>
<div class="line">replPolicy    = LRU</div>
<div class="line">hitDelay      = 2 </div>
<div class="line">lowerLevel    = L2Cache</div>
<div class="line"> </div>
<div class="line"># Write buffer</div>
<div class="line">[WriteBuffer]</div>
<div class="line">deviceType    = writebuffer</div>
<div class="line">size          = 3               # 3 entries</div>
<div class="line">hitDelay      = 1 </div>
<div class="line">lowerLevel    = DL1Cache</div>
<div class="line"> </div>
<div class="line"># Data L1 cache</div>
<div class="line">[DL1Cache]</div>
<div class="line">deviceType    = cache</div>
<div class="line">size          = 8192            # 8 * 1024</div>
<div class="line">assoc         = 1</div>
<div class="line">bsize         = 64</div>
<div class="line">writePolicy   = WB</div>
<div class="line">replPolicy    = LRU</div>
<div class="line">hitDelay      = 2</div>
<div class="line">lowerLevel    = L2Cache</div>
<div class="line"> </div>
<div class="line"># L2 cache</div>
<div class="line">[L2Cache]</div>
<div class="line">deviceType    = cache</div>
<div class="line">size          = 16384           # 16 * 1024</div>
<div class="line">assoc         = 4</div>
<div class="line">bsize         = 64</div>
<div class="line">writePolicy   = WB</div>
<div class="line">replPolicy    = LRU</div>
<div class="line">hitDelay      = 10</div>
<div class="line">lowerLevel    = Memory</div>
<div class="line"> </div>
<div class="line"># DRAM memory</div>
<div class="line">[Memory]</div>
<div class="line">deviceType    = dram</div>
<div class="line">size          = 64</div>
<div class="line">assoc         = 1</div>
<div class="line">bsize         = 64</div>
<div class="line">writePolicy   = WB</div>
<div class="line">replPolicy    = LRU</div>
<div class="line">hitDelay      = 100</div>
<div class="line">lowerLevel    = null</div>
</div><!-- fragment --><p>Here is what some of those items mean:</p>
<p>[pipeline]</p><ul>
<li>width = 1 : It is a 1-wide processor.</li>
<li>instSource = IL1Cache : The pipeline uses IL1Cache as its data source.</li>
<li>dataSource = <a class="el" href="classWriteBuffer.html" title="A write buffer.">WriteBuffer</a> : The pipeline uses <a class="el" href="classWriteBuffer.html" title="A write buffer.">WriteBuffer</a> as its data source.</li>
</ul>
<p>[<a class="el" href="classWriteBuffer.html" title="A write buffer.">WriteBuffer</a>]</p><ul>
<li>deviceType = writebuffer : The device type is a write-buffer.</li>
<li>size = 3 : Capacity is 3 entries.</li>
<li>hitDelay = 1 : Delay required to access the write-buffer is 1 cycle.</li>
<li>lowerLevel = DL1Cache : The memory object below this level is DL1Cache.</li>
</ul>
<p>[IL1Cache]</p><ul>
<li>deviceType = cache : The device type is a cache.</li>
<li>size = 8192 : Capacity is 8 KB.</li>
<li>assoc = 1 : Associativity is 1-way (a.k.a. direct-mapped).</li>
<li>bsize = 64 : <a class="el" href="classCache.html" title="A generic cache.">Cache</a> block size is 64 bytes.</li>
<li>writePolicy = WB : Write policy is write-back (not write-through).</li>
<li>replPolicy = LRU : Replacement policy is LRU (this is the only option).</li>
<li>hitDelay = 2 : Delay required to access the cache is 2 cycles.</li>
<li>lowerLevel = L2Cache : The memory object below this level is L2Cache.</li>
</ul>
<p>The instSource, dataSource, and lowerLevel parameters name a memory object by the section name that defines that object. In this way, the memory hierarchy can be configured with an arbitrary number of levels.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Trace Files</h2>
<p>You can find 8 trace files under the traces/ directory. I've listed them in the orer of difficulty.</p>
<ul>
<li>one_load.tr : One load instruction.</li>
<li>one_store.tr : One store instruction.</li>
<li>two_loads.tr : Two load instructions. The second load hits due to spatial locality.</li>
<li>two_stores.tr : Two store instructions. The second store hits due to spatial locality.</li>
<li>many_loads.tr : Many load instructions. The many loads all land on the same set and cause cache block replacements at multiple levels of the cache. LRU replacement policy is tested as well.</li>
<li>many_stores.tr : Many store instructions. The many stores all land on the same set and cause cache block replacements at multiple levels of the cache. LRU replacement policy is tested as well. The additional difficulty here is that since the blocks are dirty, write-backs will need to occur for write-back caches.</li>
<li>many_loads_then_stores.tr : All the loads in many_loads.tr followed by all the stores in many_stores.tr.</li>
<li>many_stores_then_loads.tr : The opposite of many_loads_then_stores.tr.</li>
<li>sample.tr : A moderately long trace of instructions (681 instructions).</li>
</ul>
<h1><a class="anchor" id="autotoc_md12"></a>
Your Tasks</h1>
<p>All the places where you have to complete code is clearly marked with '// TODO' comments. The only files that you would have to modify are CacheCore.cpp / <a class="el" href="CacheCore_8h_source.html">CacheCore.h</a> and Cache.cpp / <a class="el" href="Cache_8h_source.html">Cache.h</a>. While completing the methods with '// TODO' comments, feel free to add more member variables and member functions to the above files as required.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
Task 1: Implement the Cache Block Array</h2>
<p>Complete the implementation of CacheCore.cpp / <a class="el" href="CacheCore_8h_source.html">CacheCore.h</a>. The 'content' cache block array has been already allocated for you. It is up to you to interpret that array to the row and column organization shown in the cache visualizer for a set-associative cache. Start by implementing the index2Row and index2Column functions as specified according to the configured associativity. Then go on to implement the accessLine and allocateLine functions that searches for a block and allocates block in the cache respectively.</p>
<h2><a class="anchor" id="autotoc_md14"></a>
Task 2: Implement the Write-back and Write-through Caches</h2>
<p>Complete the implementation of <a class="el" href="Cache_8h_source.html">Cache.h</a> / Cache.cpp. As of now, all accesses miss in the cache and no cache block allocation is done. Complete the read, write, and writeBack functions according to what we learned in the lecture.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
Source Code</h2>
<p>I had to write some of the code in C++ this time because there was no way to cleanly implement memory objects with just C. While you may have never learned C++, don't get intimidated, it's just C with classes thrown in. The syntax for C++ classes is almost identical to Java classes with small variations. <br  />
</p>
<p>Since you are using C++ for the first time, I made sure to rigorously document all the variables and functions so everything is clear. I also used <a href="https://www.doxygen.nl/index.html">Doxygen</a> to auto-generate HTML documentation from the source code comments. The HTML files are under doc/html/ and you can open it with any web browser. Start from 'index.html'. Click on the 'Classes' tab then choose '<a class="el" href="classMemObj.html" title="A generic memory object.">MemObj</a>'. That's a good place to start because it shows you the class inheritance hierarchy starting from <a class="el" href="classMemObj.html" title="A generic memory object.">MemObj</a> which you can navigate by clicking on any of the children classes. Pay special attention to '<a class="el" href="classCacheCore.html" title="TODO: A cache block array with the given capacity, cache block size, and associativity.">CacheCore</a>', '<a class="el" href="classWBCache.html" title="TODO: A write back cache.">WBCache</a>', and '<a class="el" href="classWTCache.html" title="TODO: A write through cache.">WTCache</a>' documentation since those are the classes that you will be modifying. Doxygen only works with classes so C functions are not listed.</p>
<p>For those of you who are not familiar with C++, here are a few pointers to differences with Java:</p>
<ol type="1">
<li><p class="startli">Inheritance</p>
<p class="startli">The syntax for inheritance is:</p>
<div class="fragment"><div class="line">class Cache: public MemObj</div>
</div><!-- fragment --><p class="startli">This means that <a class="el" href="classCache.html" title="A generic cache.">Cache</a> inherits from the <a class="el" href="classMemObj.html" title="A generic memory object.">MemObj</a> class. The 'public' specifier means that public members in <a class="el" href="classMemObj.html" title="A generic memory object.">MemObj</a> remain public in <a class="el" href="classCache.html" title="A generic cache.">Cache</a>.</p>
</li>
</ol>
<ol type="1">
<li><p class="startli">Overriding Methods and Abstract Methods</p>
<p class="startli">In C++, you may often see the 'virtual' keyword before a function:</p>
<div class="fragment"><div class="line">virtual void read(MemRequest *mreq) = 0;</div>
</div><!-- fragment --><p class="startli">Unlike Java, if you want to override a method in the child class, you have to declare it as 'virtual' in the parent class. The above method is declared as part of the <a class="el" href="classCache.html" title="A generic cache.">Cache</a> class and it is declared as virtual because it is overriden in the children classes <a class="el" href="classWBCache.html" title="TODO: A write back cache.">WBCache</a> and <a class="el" href="classWTCache.html" title="TODO: A write through cache.">WTCache</a>.</p>
<p class="startli">In addition, the ' = 0;' notation says that, this method is an <em>abstract method</em>. An abstract method is a method with no implementation. So it's much like an interface in Java in spirit. Any class with an abstract method that is not overriden is called an <em>abstract class</em> and objects cannot be instantiated for an abstract class. Much like how interfaces cannot be instantiated for Java. So you cannot create a <a class="el" href="classCache.html" title="A generic cache.">Cache</a> object in this case.</p>
</li>
</ol>
<ol type="1">
<li><p class="startli">Creating and Freeing Objects</p>
<p class="startli">Creating objects in C++ is almost identical to Java: you use the 'new' keyword. The key difference is in freeing of objects. Java does automatic garbage collection. With C++, the programmer has to manually free the object using the 'delete' keyword:</p>
<div class="fragment"><div class="line">mreq = new MemRequest(dinst.inst.Addr, MemRead);</div>
<div class="line">...</div>
<div class="line">delete mreq;</div>
</div><!-- fragment --><p class="startli">As you can see in the above code in CPU.c, you have to delete every object you create using 'new' or else you will have a memory leak.</p>
</li>
</ol>
<p>As with C programs, you can use <a href="https://valgrind.org/docs/manual/QuickStart.html">valgrind</a> to detect most memory bugs in C++, including memory leaks.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Submission</h2>
<p><em>One member</em> will submit the project on behalf of the group. The submitting member will press the "View or edit group" link at the top-right corner of the assignment page after submission to add his/her partner. That way, both of you will get a grade. <br  />
</p>
<p>You will do two submissions for this deliverable.</p>
<ol type="1">
<li><p class="startli">**(90 points)** Project 2 Source Code</p>
<p class="startli">As for Project 1, the grading will be based on your diff results.</p>
</li>
</ol>
<ol type="1">
<li><p class="startli">**(20 points)** Project 2 Retrospective</p>
<p class="startli">To be released on GradeScope. <br  />
</p>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md17"></a>
Resources</h1>
<p>Please refer to <a href="https://github.com/wonsunahn/CS1541_Project1/#resources">Project 1 Resources</a> on how to test and debug your program. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
